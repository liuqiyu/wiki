# 浅谈前端缓存

## 浏览器缓存

### 三级缓存原理

```
1、先去内存看，如果有，直接加载

2、如果内存没有，择取硬盘获取，如果有直接加载

3、如果硬盘也没有，那么就进行网络请求

4、加载到的资源缓存到硬盘和内存
```

一般浏览图片，如下流程：

```
访问-> 200 -> 退出浏览器

再进来-> 200(from disk cache) -> 刷新 -> 200(from memory cache)
```

application cache和上面缓存有点区别，是离线缓存，就是资源可以从硬盘上读取而不用联网，即使断网，用户也可以浏览。

## 设置浏览器缓存

304是协商缓存还是要和服务器通信一次，要想断绝服务器通信，就要强制浏览器使用本地缓存（cache-control/expires），

一般有如下几种方式设置浏览器缓存。

#### 1、通过HTTP的META设置expires和cache-control

```
<meta http-equiv="Cache-Control" content="max-age=7200" />
<meta http-equiv="Expires" content="Sun Oct 15 2017 20:39:53 GMT+0800 (CST)" />
```

#### 2、apache服务器配置图片，css，js，flash的缓存



## 缓存的种类

* CDN缓存

* DNS缓存

* 客户端缓存
    * 无需请求服务器的 `memory cache`、 `disk cache`
        * `200 from memory cache`:  不访问服务器，直接读缓存，从内存中读取缓存。此时的数据时缓存到内存中的，当kill进程后，也就是浏览器关闭以后，数据将不存在。但是这种方式只能缓存派生资源
        * `200 from disk cache`: 不访问服务器，直接读缓存，从磁盘中读取缓存，当kill进程时，数据还是存在。这种方式也只能缓存派生资源
        * `304 Not Modified`: 访问服务器，发现数据没有更新，服务器返回此状态码。然后从缓存中读取数据。
    * 需要请求的 `Etag`、 `Last-Modify304`
        * `Etag`
        * `Last-Modify304`
    
* Service Worker与缓存及离线缓存

* PageCache与ajax缓存

## 1）CDN缓存

看到一个形象的比喻，来比喻CDN。

10年前，还没有火车票代售点一说，12306.cn更是无从说起。那时候火车票还只能在火车站的售票大厅购买，而我所在的小县城并不通火车，
火车票都要去市里的火车站购买，而从我家到县城再到市里，来回就是4个小时车程，简直就是浪费生命。后来就好了，小县城里出现了火车票代售点，
甚至乡镇上也有了代售点，可以直接在代售点购买火车票，方便了不少，全市人民再也不用在一个点苦逼的排队买票了。

CDN就可以理解为分布在每个县城或者乡镇的火车票代售点，用户在浏览网站的时候，CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求，
这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了。

### 优势

* CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；

* 大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载；

关于CDN缓存 ，在浏览器本地缓存失效后，浏览器会向CDN边缘节点发起请求。类似浏览器缓存，CDN边缘节点也存在着一套缓存机制。
CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的

> Cache-control: max-age

的字段来设置CDN边缘节点数据缓存时间。

当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；
否则，CDN节点就会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。
 CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。
 
### CDN缓存刷新

CDN边缘节点对开发者是透明的，相比于浏览器Ctrl+F5的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。
这样开发者在更新数据后，可以使用“刷新缓存”功能来强制CDN节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。

## 2）DNS缓存

`DNS(Domain Name System)`： 负责将域名URL转化为服务器主机IP。

DNS查找流程：首先查看浏览器缓存是否存在，不存在则访问本机DNS缓存，
再不存在则访问本地DNS服务器。所以DNS也是开销，通常浏览器查找一个给定URL的IP地址要花费20-120ms，在DNS查找完成前，浏览器不能从host那里下载任何东西。

TTL(Time To Live)：表示查找返回的DNS记录包含的一个存活时间，
过期则这个DNS记录将被抛弃。浏览器DNS缓存也有自己的过期时间，这个时间是独立于本机DNS缓存的，相对也比较短，例如chrome只有1分钟左右。

### DNS性能优化最佳实践、

当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。所以减少唯一主机名的数量就可以减少DNS查找的数量。

但是问题来了，有时候需要多设置主机数量，来增加DNS的负载均衡，因此减少DNS查找和增加主机数量形成了矛盾关系，
经过实战DNS设置2-4个主机名是最佳的。更多负载均衡可以用其他方式实现，例如用nginx做负载均衡！

## 3）浏览器缓存策略之客户端缓存

### 1、Cache-control: max-age

假设你的站点有引用一个脚本文件，你非常确认这个脚本文件内容五十年不变。那么自然希望浏览器把这个脚本缓存起来，
不用每一次都请求服务器，然后服务器再返回相同的内容。这样能够节省带宽开销并且提升性能。

此时你只需要设置文件返回的HTTP头中的Cache-Control设置为：

> Cache-Control: max-age=31536000

虽然是五十年不变，但是标准中规定max-age值最大不能超过一年，又因为是以秒为单位，所以值为31536000

例如这个五十年不变的脚本地址是 www.haorooms.com/never-expire.js 那么接下来每次用户请求这个地址时，浏览器都不会再向服务器发出请求，
而是直接从本地的浏览器缓存中取。直到一年以后或者用户手动的清除了缓存。

但是，如果这一年中的某一天你发现脚本内容必须要更改了怎么办？很简单，改变请求的文件名就好了，例如never-expire-v2.js。

Max-age 使用秒来计量，如：

> Cache-Control:max-age=645672

指定页面645672秒（7.47天）后过期。

### 2、Expires

设置了Expires也可以避免浏览器和服务器发请求，直到时间过期。

**以上2个缓存，遵循三级缓存原理**

```
先去内存看，如果有，直接加载

如果内存没有，择取硬盘获取，如果有直接加载

如果硬盘也没有，那么就进行网络请求

加载到的资源缓存到硬盘和内存
```

一般浏览图片，如下流程：

```
访问-> 200 -> 退出浏览器

再进来-> 200(from disk cache) -> 刷新 -> 200(from memory cache)
```

### 3、Last-Modified 304协商缓存

服务器为了通知浏览器当前文件的版本，会发送一个上次修改时间的标签，例如：

> Last-Modified:Tue, 06 Jan 2018 08:26:32 GMT

假如是304协商缓存，验证步骤如下：

```
浏览器：Hey，我需要jquery.min.js这个文件，如果是在 Last-Modified:Tue, 06 Jan 2018 08:26:32 GMT 之后修改过的，请发给我。

服务器：（检查文件的修改时间）

服务器：Hey，这个文件在那个时间之后没有被修改过，你已经有最新的版本了。

浏览器：太好了，那我就显示给用户了。
```

### 4、ETag

上面截图中也圈出来了，其实Etag和304类似，但是级别比 Last-Modified 高一些。

请求过程如下：

```
1. 浏览器：Hey，我需要haorooms的main.css这个文件，有没有不匹配"61213-1762a-50bf790757204"这个串的

2. 服务器：（检查ETag…）

3. 服务器：Hey，我这里的版本也是"61213-1762a-50bf790757204"，你已经是最新的版本了

4. 浏览器：好，那就可以使用本地缓存了
```

## 4）Service Worker与缓存及离线缓存

随着Service Worker（以下简称SW）的普及和规范，我们可以使用SW提供的缓存接口替代HTTP缓存。
当然SW的功能是强大的，除了缓存功能，还能够使用它来实现离线、数据同步、后台编译等等。

## 5）PageCache与Ajax可缓存

PageCache其实是facebook提出的，解决ajax缓存的一种方案！简单的说，就是将访问过的页面缓存在客户端。
但我们知道，作为Facebook这样交互性很强的网站，需要保障用户能尽早的获得更新后的信息，而不是给用户展示一个毫无意义的过期页面。

Facebook设计了一个框架来识别一个页面是否来自于缓存（猜测：页面首次加载完毕后将所有Ajax的Callback和Result缓存在本地
Facebook页面是基于Ajax获取页面内容，参见BigPipe），若来自于缓存，通过Ajax来更新所需更新的模块
（猜测：通过JS预先定义本页面所需更新的div Id及对应的callback handler，并在页面下载时同时下载下来）。

其提到了三种更新类型：增量更新，用户复写（例如用户在页面上回复了一则评论）及跨页更新（例如在消息详细页面将一则消息标识为已读，
需将首页的未读消息数进行更新。）。核心思路还是依据Ajax进行更新。具体思路为：

```
1、增量更新：只要页面来自于缓存，即更新所有预定义的需增量更新的模块。

2、用户复写：通过HistoryManager记录用户操作并在cache页面读取后重放所有被标记为“replayable”的操作。

3、跨页更新：通过服务端Database API发送信号至客户端将过期缓存标识为invalid（不清楚如何实现。也许是DB端提供一个开放的webservice，
客户端通过Ajax持续访问此API来获得此信息）。获得了缓存过期信号后，通过Ajax更新需要更新的信息。
```

Facebook顺带提到了一个更新Ajax内容避免页面变化/闪烁的小技巧，就是先将需更新的地方设置为blank，而非直接更新其内容。

## 缓存情况下前端代码部署


## 总结

1、 配置超长时间的本地缓存 —— 节省带宽，提高性能

2、采用内容摘要作为缓存更新依据 —— 精确的缓存控制

3、 静态资源CDN部署 —— 优化网络请求

4、更资源发布路径实现非覆盖式发布 —— 平滑升级